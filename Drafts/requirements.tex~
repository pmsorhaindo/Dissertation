\documentclass[main.tex]{subfiles} 
\begin{document}

\section{Requirements}
After preliminary research, the following aims were laid out for the technical and qualitative aspects of the produced simulation, in regard to the behaviour of the simulation and the ants within it. Also listed are the learning outcomes which were to be achieved throughout the project.

\paragraph{Technical Aims}
\begin{itemize}
	\item To explore parallelism and implement parallel and sequential algorithms.
	\item To produce functional code that addresses the problem.
	\item To implement accurate collision detection.
	\item To implement a data structure that holds the information in the simulation.
	\item To develop custom algorithms suitable for this project.
\end{itemize}

\paragraph{Qualitative Aims}
\begin{itemize}
	\item To produce ants which have a sense of  position and can navigate their environment
	\item To produce ants which appear to interact through the use of pheromones
	\item To produce environments of varying size in order to test the simulations scalability
	\item To produce clear concise and understandable code.
\end{itemize}

\paragraph{Learning Outcomes}
\begin{itemize}
	\item To be able to program functionally
	\item To have a better understanding of parallelism
	\item To have a good understanding of the programming language(s) that I use to implement my solution.
	\item To be able to analyse and critique algorithms effectively.
\end{itemize}

\paragraph{Technical Requirements}
Above all the aim of the project it to exploit the parallelism exposed by purely function in Haskell. The resulting artefact will be tested in three ways in order to determine whether it has made effective use of parallelism within the simulation. Firstly attempts will be made to produce functions which run the simulation in a serial manner in order to compare the runtimes of the parallel design with the serial. Secondly, varying loads will be placed on the simulation, this will be achieved by creating worlds dynamically from a set of parameters. Thirdly, the simulations design must allow for varying degrees of parallel granularity. The parameters introduced from these different levels of granularity can then be used to fine-tune the simulation to determine optimum settings and better assess where introducing parallelism makes improvements on run time and where it does not due to increased overheads.

\paragraph{Data Structures and Collision Detection} The design produced should allow for collision detection to take place efficiently and accurately. Ants must not be displayed as intersecting at any point during the simulation. This may be achieved a priori through continuous collision detection as discussed during research or a posteriori by means of discrete collision detection with an adjustment phase to prevent intersected ants being shown. The data structure should also assist in pruning unnecessary collision tests from needing to be computed. This will ultimately increase the efficiency of the simulation and allow for a final product which scales well with the problem size.

\paragraph{Iterative Development} It will be critical to test all code as it is produced, this not only saves time debugging but testing the final project build is more likely to be successful. The language Haskell, in which this project will be undertaken, allows this approach to development to be taken naturally through its rich and powerful type system. The use of type signatures as annotations to functions allows the programmer to specify the type of values the function should expect as parameters and the expected type of the return value this makes ``it impossible to write code violating chosen constraints'' \cite{OSullivan2008}. As well as writing test cases and running the program to see if its functionality is correct, Haskell's QuickCheck package will be used to perform algebraic testing on key functions within the simulation. Given properties that functions must hold and knowing the data types of both the functions parameters and the returned result, QuickCheck automatically generates test data to feed the functions and tests the result against the specified property to see if the function passes the test. Running QuickCheck notifies the programmer when properties aren't up held and allows for fast and rigorous testing of the application taking an algebraic approach.

\paragraph{Aesthetic Requirements}
The behaviour of the project's resulting artefact aims to portray a functioning ant colony. Ants should seek out food using exploratory strategies, communicate locations of food to other ants in the colony using pheromones and return to the colony's nest with food. The ant colonies increasing size should be reflected in the size of the nest, and the nests size in turn will dictate the amount of new ants generated by the colony. The nest's physical size will grow relative to the amount of food successfully brought back to the colony by the ants in the simulation.

\paragraph{Exploratory Strategies} Ants will explore the simulation world by moving randomly away from the nest, each ant will have a direction property which when set allows them to track their location relative to where they have already been. One example of the use of storing directions within the ant is to detect when an ant has made a circle and returned to a location it has been before. Then an ant will then be able to make the decision not to take the same path as it had previously leading to more intelligent exploration strategies. Another example of an exploration strategy is moving away from ants which are not holding food and going in the opposite direction to ants who are carrying food, if ants carrying food are looking to return to the colony this would also be an effective strategy.

\paragraph{}To communicating locations of food, once an ant locates food within the simulation, it will excrete pheromone which will be left on the ant and on the current location where the food has been located. Ants will also be tainted slightly with the pheromone from their current location, this coupled with the surface of the simulation dissipating pheromone every simulation step will allow ants to leave a dynamic path towards food sources by leaving a trail of pheromone. Once ants who are currently searching for food detect a pheromone indicating food they would be able to adjust their exploration strategy to detect which surrounding cell has the greatest pheromone level and use this trail to find food more efficiently.

\paragraph{}The behaviour of returning to the colony, could also be achieved through the use of a different pheromone, or by allowing ants to retrace their steps. The preferred behaviour of the simulation's ants would use a mixture of the two, as ants are unlikely to remember the entire path back to their nest. Upon returning to the colony with food the ants will .The amount of ants added to the simulation will increase relative to how much food is brought back to the nest. Thus, the ants task of bringing food back to the nest enables the colony to fulfil its task of increasing in size.

\end{document}
%[AWC 1156]
