\documentclass[main.tex]{subfiles} 
\begin{document}
%% my design content

Design

Desgin techniques
Unlike imperative languages such as Java and C++ Haskell does not use classes to create objects and then send messages between objects. Rather it uses Declarative and Data-driven methods to process data. Haskell doesn't strictly speaking do any of these; because it is the programmer that does things using Haskell. This makes it more natural for imperative or Object Oriented programmers to take a different approach when programming in Haskell. It is critically important to use the right technique or tool for the job at hand.

There is no standard way to model programs in Haskell and many different methods are used to carry an idea through from concept to code. Some programmers use modelling techniques similar to the Unified Modeling Language (UML) [Which is geared heavliy towards object orientated languages whith its use of class diagrams/Commonly used in object-orientated languages such as Java] While other developers use concept maps and data flow diagrams to provide a general picture of the design before they begin programming. However, because Haskell is a strongly and statically typed language it is a common practise to start by figuring out the data types needed to complete the task. Then implement the functions for working with the newly created data types. Finally culminating in writing modules that bring together all the functions in a structured way. The approach to modelling however, differs from project to project.
%Modelling Programs in Haskell (Real World Haskell: JSON library chapter)

The classes used by Haskell are similar to those used in other object-oriented languages such as C++ and Java. However, there are some significant differences:

Haskell separates the definition of a type from the definition of the methods associated with that type. A class in C++ or Java usually defines both a data structure (the member variables) and the functions associated with the structure (the methods). In Haskell, these definitions are separated. The class methods defined by a Haskell class correspond to virtual functions in a C++ class. Each instance of a class provides its own definition for each method; class defaults correspond to default definitions for a virtual function in the base class.

Haskell does not support the C++ overloading style in which functions with different types share a common name.
The type of a Haskell object cannot be implicitly coerced; there is no universal base class such as Object which values can be projected into or out of.
C++ and Java attach identifying information (such as a VTable) to the runtime representation of an object. In Haskell, such information is attached logically instead of physically to values, through the type system.
There is no access control (such as public or private class constituents) built into the Haskell class system. Instead, the module system must be used to hide or reveal components of a class.
(Gentle introduction to Haskell Version 98)


Data types in Haskell and then quick checks [ Method::Type-> Type -> Type  - Method x y = undefined  - quickCheck]
-- reference

UML is not limited to OOP. Even though it's founded in OOA/D it can be adapted a long way. The data structures are typically determined by the operations one wishes to run on them, so the usefulness of a diagram ultimately lies with t depends on the kind of UML model do you wish to make

Parametric polymorphism's also remarkably effective at helping strip out the irrelevant

Predicted code flow of the application
On the function/method level.
More detailed than that.


High level parallel design (pmap) discussion.
`par `seq` annotations and other forms of denoting parallelism.

Data flow

Representing Source code

(
Talk about the non parallel
Then the parallel version

Split into Epochs of design

Mind map
)

Alternate designs
Everthing is based on message passign ants are grouped into oiiks and processed in batches by threads/ processors. Each processor gets representation of the world and sends requests to all other processors to check if it can move its ant in a particular direction, this design is possible more suitable for Erlang



Representation of the Simulation world - Split into Epochs of design

The design of the simulation went through many iterations.

The list based Worlds design free movement
The  initial concept for the data representation of the simulation world was to produce a list for every type of item in the world. For instance there would be an Ant List, a Food List a Surface Type List. Each item in the list would also be given a location to represent where it was on in the simulation world. â€Ž

List based Worlds location tags

Graph based World Hold all

Graph based Worlds non parallel

Graph based Worlds parallel





The initial concept for the representation of the simulation world was list based. Several lists would be produced for everything in the world, for an example a list of Ants currently in the simulation, a list of Food currently in the simulation and a list of the surfaces in the simulation. Each element in the lists would hold a location value and 



Types
The types that will be involved in modeling the simulation of an Ant colony are as follows.

Ant          :: Ant
Pheremone    :: Double
Food         :: Double
Nest         :: Bool
AntQuadrant  :: Graph -> Holds- Possible Ant
PherQuadrant :: Graph -> Holds- Pheremone Level
FoodQuadrant :: Graph -> Holds- Possible Food
NestQuadrant :: Graph -> Holds- Possible NestArea
AntWorld     :: Graph -> Holds- Many Ant Quadrants
PherWorld    :: Graph -> Holds- Many PherQuadrants
FoodWorld    :: Graph -> Holds- Many FoodQuadrants
NestWorld    :: Graph -> Holds- Many NestQuadrants

Key Functions
The functions responsible for the flow of the program are

stitchUpAntQuads - Sequentially processes pairs of edge-nodes on a Graph (to possibly move Ants between AntQuadrants).
stitchUpPherQuads - Sequentially processes pairs of edge-nodes on a Graph (to manage the spread of Phermone between PherQuadrants).

processAntQuadrant - Moves each Ant within a quadrant.
processPherQuadrant - Evaporates the Pheremone 


Main
Given Starting parameters create a World.
-Parameters
Size of Quadrant :: Int
Size of World :: Int
Amount of Ants :: Int
Amount of Food :: Int

-Initialize random nest area proportional to the amount of Ants.
-Randomly position Ants around the Nest Area
-Randomly position Food (not In Food Area)
-Initialize all PherQuadrants as 0 except for Food Quadrants which maintain 10.0

Simulation Loop

In parallel
-stitchAntQuads
-stitchPherQuads

In parallel
- processAntQuads
- processPherQuads

Display


ReQuading 
Graph Density
calculating densest points NP-hard?

When graphs are split at densest points
More serial calculations.

QUICK CHECK NOTES




%% more of my design content

\end{document}

%[AWC 985]
