\documentclass[main.tex]{subfiles} 
\usepackage{listings}
\lstset{language=Haskell}
\begin{document}

Desgin techniques
There is no standard way to model programs in Haskell and many different methods are used to carry an idea through from concept to code. Some programmers use modelling techniques similar to the Unified Modeling Language (UML) [Which is geared heavliy towards object orientated languages with its use of class diagrams/Commonly used in object-orientated languages such as Java] While other developers use concept maps and data flow diagrams to provide a general picture of the design before they begin programming. However, because Haskell is both a strongly and statically typed language it is a common practise to start constructing a program by working out the data types needed to complete the task. Then implement the functions for working with the newly created data types. Finally culminating in writing modules that bring together all the functions in a structured way. The approach to modelling however, differs from project to project.
%Modelling Programs in Haskell (Real World Haskell: JSON library chapter)

Data types in Haskell and then quick checks [ Method::Type-> Type -> Type  - Method x y = undefined  - quickCheck]
-- reference

UML is not limited to OOP. Even though it's founded in OOA/D it can be adapted a long way. The data structures are typically determined by the operations one wishes to run on them, so the usefulness of a diagram ultimately lies with t depends on the kind of UML model do you wish to make

Parametric polymorphism's also remarkably effective at helping strip out the irrelevant (use of type variables in)


Points to consider when desiging a parallel Algorithm
Granularity
Load Balancing
Dependancy - Dependancy Graphs - http://msdn.microsoft.com/en-us/library/ee847415.aspx
Scheduling

The partitioning phase of a design should produce one or more possible   decompositions of a problem. Before proceeding to evaluate communication requirements, Ian Foster [ Designing and Building Parallel Programs  1995 by Ian Foster] reccomends the use of the following checklist to ensure that the design has no obvious flaws. Generally, all these questions should be answered in the affirmative.

Does your partition define at least an order of magnitude more tasks than there are processors in your target computer? If not, you have little flexibility in subsequent design stages.
Does your partition avoid redundant computation and storage requirements? If not, the resulting algorithm may not be scalable to deal with large problems.
Are tasks of comparable size? If not, it may be hard to allocate each processor equal amounts of work.
Does the number of tasks scale with problem size? Ideally, an increase in problem size should increase the number of tasks rather than the size of individual tasks. If this is not the case, your parallel algorithm may not be able to solve larger problems when more processors are available.
Have you identified several alternative partitions? You can maximize flexibility in subsequent design stages by considering alternatives now. Remember to investigate both domain and functional decompositions.
%Answers to these questions may suggest that, despite careful thought in this and subsequent design stages, we have a ``bad'' design. In this situation it is risky simply to push ahead with implementation. We should use the performance evaluation techniques described in Chapter 3 to determine whether the design meets our performance goals despite its apparent deficiencies. We may also wish to revisit the problem specification. Particularly in science and engineering applications, where the problem to be solved may involve a simulation of a complex physical process, the approximations and numerical techniques used to develop the simulation can strongly influence the ease of parallel implementation. In some cases, optimal sequential and parallel solutions to the same problem may use quite different solution techniques. While detailed discussion of these issues is beyond the scope of this book, we present several illustrative examples of them later in this chapter.
[Ian Foster]

High level parallel design (pmap) discussion.
Map Reduce
-In a purely functional setting, elements of a list being computed by map cannot see the effects of the computations on other elements
-If order of application of f to elements in list is commutative, we can reorder or parallelize execution
-This is the “secret” that MapReduce exploits
Actors
Embarassingly Parallel
Replicable
Repository
Pipeline A series of ordered but independent computation stages need to be applied on data,
where each output of a computation becomes input of subsequent computation

`par `seq` annotations and other forms of denoting parallelism.



-Predicted code flow of the application
On the function/method level.
More detailed than that.

Data flow

Representing Source code

(
Talk about the non parallel

Then the parallel version

Split into Epochs of design

Mind map
)

Alternate designs
Everthing is based on message passing ants are grouped into oiiks and processed in batches by threads/ processors. Each processor gets representation of the world and sends requests to all other processors to check if it can move its ant in a particular direction, this design is possible more suitable for Erlang



Representation of the Simulation world - Split into Epochs of design

The design of the simulation went through many iterations.

Alternative considered designs
Everything is Based on Message passing Ants are grouped in Pools and Pools are processed by seperate cores, processors or machines. Each Processor gets a reperesentation of the world and sends and recieves requests to find  out if it can move its ant to the cell it wishes. This design is possibly more suited to Erlang and the Actor model.



The list based Worlds design free movement
The initial concept for the representation of the simulation world was list based. Several lists would be produced for everything in the world, for an example a list of Ants currently in the simulation, a list of Food currently in the simulation and a list of the surfaces in the simulation. Each element in the lists would hold a location value and --------------------
The  initial concept for the data representation of the simulation world was to produce a list for every type of item in the world. For instance there would be an Ant List, a Food List a Surface Type List. Each item in the list would also be given a location to represent where it was in the simulation world. Each list could then be processed in parallel. Copies of each list would be made for lists which needed other lists in order to compute their changes. Once each list had updated the old lists would be discarded and  copies of the new lists would once again be made for the next simulation step.‎ The locations held by each item would have an x and y value, and information radius or a second x and y in order to calculate a bounding box.

List based Worlds location tags
This approach was similar to the previous idea, using lists to process objects of similar types. However placing a restriction that x and y coordinates must be integers and each location is the size of one ant. This concept influenced all following design decisions, making it trivial to reason about collision detection. The more rigid location system doesn't only aid in collision detection but now help when considering parallel strategies like map reduce, the reduction step will be alot simpler. partitioning the wor

Graph based World Hold all
Using a Graph representation of the world Collitions are cheap, the adjacency list of the graph always holds the locations of the surrounding nodes and making inquires as to what is in surrounding cells is straight forward as only the nodes in the adjacency list have to be queried.

Graph based Worlds non parallel

Graph based Worlds parallel

Evolution of the Ant,
Originally held its location, this is now held by knowing its position within the graph. Considered making each Ant a stateful monad, seemed to be confusing the state Monad and dropped this idea.
Holding its Direction facing
list of where it has been.
Age, incremented each step. (incremented at each step/simulation days.)
Its current behaviour (Bool,Bool,Bool) changed to a parametric data type.
Recognition of circles; so s,w,n,e would be pruned from the list and the and would be able to make the decision not to go South on its next move, unless the pheremone was now higher or it was returning home.

Types
The types that will be involved in modeling the simulation of an Ant colony are as follows.

\begin{lstlisting}


Ant          :: Ant
Pheremone    :: Double
Food         :: Double
Nest         :: Bool
AntQuadrant  :: Graph -> Holds- Possible Ant
PherQuadrant :: Graph -> Holds- Pheremone Level
FoodQuadrant :: Graph -> Holds- Possible Food
NestQuadrant :: Graph -> Holds- Possible NestArea
AntWorld     :: Graph -> Holds- Many Ant Quadrants
PherWorld    :: Graph -> Holds- Many PherQuadrants
FoodWorld    :: Graph -> Holds- Many FoodQuadrants
NestWorld    :: Graph -> Holds- Many NestQuadrants

\end{lstlisting}


Key Functions
The functions responsible for the flow of the program are


(MENTIONED-IN-IMPLEMENTATION) (Need to discuss hyper jumping (ants holding the state if they had been moved or not(is that more processing), message systems quadrants telling other quadrants that they which to pass ants. STM edge cells being locable concurrency style)).
stitchUpAntQuads - Sequentially processes pairs of edge-nodes on a Graph (to possibly move Ants between AntQuadrants).
The could be parallelised to a degree - Enter processing batches!
stitchUpPherQuads - Sequentially processes pairs of edge-nodes on a Graph (to manage the spread of Phermone between PherQuadrants).

processAntQuadrant - Moves each Ant within a quadrant.
processPherQuadrant - Evaporates the Pheremone 


Main
Given Starting parameters create a World.
-Parameters

\begin{lstlisting}
Size of Quadrant :: Int
Size of World :: Int
Amount of Ants :: Int
Amount of Food :: Int

\end{lstlisting}


-Initialize random nest area proportional to the amount of Ants.
-Randomly position Ants around the Nest Area
-Randomly position Food (not In Food Area)
-Initialize all PherQuadrants as 0 except for Food Quadrants which maintain 10.0

Simulation Loop

Parallelisable functions
-stitchAntQuads
-stitchPherQuads

In parallel
- processAntQuads
- processPherQuads

Display


ReQuading 
Graph Density
calculating densest points NP-hard?

When graphs are split at densest points
More serial calculations.

QUICK CHECK NOTES



How the design choices have been influenced by research.

%% more of my design content
\section{Planning}

\section{Software Development Model}
This project will take an iterative and modular approach to development. This approach can also be seen as ``a way to manage the complexity and risks of large-scale development''\cite{Larman2003}.  It is a useful coding practise to develop small modules which are capable of functioning independantly from the code as these modules can then be reused, in developing other programs. There is also another advantage to be drawn from modular development, each module would be able to be tested sperately which would in turn ensure less bugs when assembling the final product. Another advantage of the iterative incremental approach is that the developer is able to take advantage of what is learned during the development of earlier, increments of the system. As learning comes from both the development and use of the system \cite{Larman2003}.

\section{Important Tasks}
The following is a break down of the project into smaller iterations this can then be used alongside the various project deadlines the project entails, to produce a Gantt chart of how the project's workflow will be carried out.
\begin{itemize}
	\item Representing an Ant
	\item Representing the World
	\item Representing the Pheremone Levels
	\item Individual Ant Intelligence
	\item Collision Detection
	\item Parallelize Algorithms further
	\item Distributing Problem
\end{itemize}

\section{A Schedule of Activities}
The produced Gantt chart attached to this report visualizes the following information. Throughout the following paragraphs a description of the plan for the project will be detailed in the form of a schedule. 

\paragraph{October-November}
Throughout the course of October and November the project will focus mainly on gathering resources  and research. Much of the research will be conducted in the functional language Haskell and small experiments will be made to demonstrate any concepts that have been learnt. Further research will be carried out in areas of the project that will pose potential problems that need to be dealt with later on in the implementation stage of the project. Even at this point in the project the implementation process will begin. As development will be iterative small aims will be set such as representing a single ant and then these aims will be expanded upon.

\paragraph{December-Janurary}
In the months of December and Janurary the code produced in the first section will be expanded upon to produce a working base system. At the end of this this period a simulation of the ant colony should be able to be run. The simulation should include the all the basic functionality of the final system. Ants will be able to move and collide. Each ant will respond to its surroundings by referencing its own basic behaviour tree.

\paragraph{February-March}
In Feburary and March the focus will be on improving the algorithms which have been used within the system. Making them more efficient and looking at structuring more of them to work in parallel. At the end of this period the project's delieverable, the simulation, will be in a state that is presentable with as few bugs as possible. Towards the end of this period if things are on schedule the project's focus will shift from improving the base simulation to adding extentions and making it more usable.

\paragraph{April}
During the final few weeks of the project there will be the fixing of any bugs in the simulation and finishing up any extentions that may be added to the project. During this time the projects focus will be on documentation and producing an informative and evaluative technical report.

\section{Risk Analysis} % Good maybe expand
Throughout this project there are several things that could go wrong, such as  loss of work, hardware failure and the inability to surpass certain bugs which may be encountered throughout the project. To minimize the chances of loss of work source control tools will be utilized in the form of git. This will not only backup the project but keep a track of changes and monitor its evolution. In the event of hardware failiure all the software required for the project is freely available and it would be possible to set up for work either in the University or on a replacement system with minimal effort. There is also a chance that bugs may be encountered which appear impossible to overcome this is a risk that can only be managed through planning and research. Should difficulties be encountered there is a vast range of resources for functional programming online and a Brighton functional programming user group, this would provide a great opportunity to increase my knowledge but should it not be possible to find a solution the only course of action would be to alter the future plans of the project.
%(!TODO) A risk analysis of potential problems.
\end{document}

%[AWC 1073]
