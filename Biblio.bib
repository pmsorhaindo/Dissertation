% This file was created with JabRef 2.7.
% Encoding: Cp1252

@INCOLLECTION{Beni1993,
  author = {Beni, Gerardo and Wang, Jing},
  title = {Swarm Intelligence in Cellular Robotic Systems},
  booktitle = {Robots and Biological Systems: Towards a New Bionics?},
  publisher = {Springer Berlin Heidelberg},
  year = {1993},
  editor = {Dario, Paolo and Sandini, Giulio and Aebischer, Patrick},
  volume = {102},
  series = {NATO ASI Series},
  pages = {703-712},
  note = {10.1007/978-3-642-58069-7_38},
  __markedentry = {[Mikey:6]},
  abstract = {Cellular Robotic Systems are capable of ’intelligent* behavior. The
	meaning of this intelligence is analyzed in the paper. We define
	robot intelligence and robot system intelligence in terms of unpredictability
	of improbable behavior. The concept of unpredictability is analyzed
	in relation to (1) statistical unpredictability, (2) inaccessibility,
	(3) undecidability, (4) intractability, and (5) non-representability.
	We argue that the latter two type of unpredictability, when exhibited
	by systems capable of producing order, can result in a non-trivial,
	different form of intelligent behavior (Swarm Intelligence). Engineering
	problems related to Swarm Intelligence are mentioned in relation
	to Cellular Robotic Systems which consist of collections of autonomous,
	non-synchronized, non-intelligent robots cooperating to achieve global
	tasks.},
  affiliation = {College of Engineering, University of California, Riverside, 92521
	Riverside, California, USA},
  isbn = {978-3-642-58069-7},
  keyword = {Computer Science},
  owner = {Mikey},
  timestamp = {2011.10.23},
  url = {http://dx.doi.org/10.1007/978-3-642-58069-7_38}
}

@BOOK{OSullivan2008,
  title = {{Real World Haskell}},
  publisher = {O'Reilly Media, Inc.},
  year = {2008},
  author = {O'Sullivan, Bryan and Goerzen, John and Stewart, Don},
  edition = {1},
  month = dec,
  abstract = {{This easy-to-use, fast-moving tutorial introduces you to functional
	programming with Haskell. You'll learn how to use Haskell in a variety
	of practical ways, from short scripts to large and demanding applications.
	\_Real World Haskell\_ takes you through the basics of functional
	programming at a brisk pace, and then helps you increase your understanding
	of Haskell in real- world issues like I/O, performance, dealing with
	data, concurrency, and more as you move through each chapter.
	
	
	With this book, you will:
	
	 * Understand the differences between procedural and functional programming
	
	 * Learn the features of Haskell, and how to use it to develop useful
	programs
	
	 * Interact with filesystems, databases, and network services
	
	 * Write solid code with automated tests, code coverage, and error
	handling
	
	 * Harness the power of multicore systems via concurrent and parallel
	programming
	
	You'll find plenty of hands-on exercises, along with examples of real
	Haskell programs that you can modify, compile, and run. Whether or
	not you've used a functional language before, if you want to understand
	why Haskell is coming into its own as a practical language in so
	many major organizations, \_Real World Haskell\_ is the best place
	to start.}},
  citeulike-article-id = {3482554},
  citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&amp;path=ASIN/0596514980},
  citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21&amp;path=ASIN/0596514980},
  citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21&amp;path=ASIN/0596514980},
  citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0596514980},
  citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0596514980/citeulike00-21},
  citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0596514980},
  citeulike-linkout-6 = {http://www.worldcat.org/isbn/0596514980},
  citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0596514980},
  citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0596514980&index=books&linkCode=qs},
  citeulike-linkout-9 = {http://www.librarything.com/isbn/0596514980},
  day = {01},
  howpublished = {Paperback},
  isbn = {0596514980},
  keywords = {functional, haskell, lib-musil, programming, tutorial},
  owner = {Mikey},
  posted-at = {2009-02-07 16:44:09},
  priority = {2},
  timestamp = {2011.10.24},
  url = {http://www.worldcat.org/isbn/0596514980}
}

@ARTICLE{Trinder1998,
  author = {Philip W. Trinder and Kevin Hammond and Hans-Wolfgang Loidl and Simon
	L. {Peyton Jones}},
  title = {Algorithm + {S}trategy = {P}arallelism},
  journal = {Journal of Functional Programming},
  year = {1998},
  volume = {8},
  pages = {23-60},
  number = {1},
  month = {jan},
  abstract = {Philip W. Trinder, Kevin Hammond, Hans-Wolfgang Loidl, and Simon L.
	Peyton Jones. Journal of Functional Programming, 8(1), Jan 1998.
	
	The process of writing large parallel programs is complicated by the
	need to specify both the parallel behaviour of the program and the
	algorithm that is to be used to compute its result. This paper introduces
	evaluation strategies, lazy higher-order functions that control the
	parallel evaluation of non-strict functional languages. Using evaluation
	strategies, it is possible to achieve a clean separation between
	algorithmic and behavioural code. The result is enhanced clarity
	and shorter parallel programs.
	
	
	Evaluation strategies are a very general concept: this paper shows
	how they can be used to model a wide range of commonly used programming
	paradigms, including divide-and-conquer, pipeline parallelism, producer/consumer
	parallelism, and data-oriented parallelism. Because they are based
	on unrestricted higher-order functions, they can also capture irregular
	parallel structures. Evaluation strategies are not just of theoretical
	interest: they have evolved out of our experience in parallelising
	several large-scale parallel applications, where they have proved
	invaluable in helping to manage the complexities of parallel behaviour.
	Some of these applications are described in detail here. The largest
	application we have studied to date, Lolita, is a 60,000 line natural
	language engineering system. Initial results show that for these
	programs we can achieve acceptable parallel performance, for relatively
	little programming effort.},
  owner = {Mikey},
  timestamp = {2011.10.23}
}

@comment{jabref-meta: selector_review:}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

